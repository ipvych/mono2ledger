#!/usr/bin/env python3
import argparse
import itertools
import json
import os
import re
import shlex
import subprocess
import sys
import time
import tomllib
from datetime import datetime, timedelta
from urllib.error import HTTPError
from urllib.parse import urljoin
from urllib.request import Request, urlopen

# TODO: Implement cache. Fetching takes too much time. Caching should be visible by
# user by showing a message with instruction on how to ignore cache as needed. Config
# option for this would also be quite nice
# TODO: Proper config parser module which will check for required fields and print
# warnings like for case where recomended value is not set
# Also invalid values should have proper error description rather than just exceptions
from pycountry import currencies

Currency = list(currencies)[0].__class__


ENDPOINT = "https://api.monobank.ua"
# TODO: Dates should be taken from config with defaults set here
# Date format used by ledger

# Datetime format used in header
HEADER_DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"
TRANSFER_MCC = 4829


def get_config():
    """Return parsed content of config file."""
    config_file = os.path.join(
        os.getenv("XDG_CONFIG_HOME", os.path.expanduser("~/.config")),
        "mono2ledger/config.toml",
    )
    with open(config_file, "rb") as file:
        return tomllib.load(file)


def get_api_key():
    config_command = config.get("api_key_command")
    if command := (os.getenv("MONO2LEDGER_API_KEY_COMMAND") or config_command):
        proc = subprocess.Popen(
            shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = proc.communicate()
        if proc.returncode != 0:
            raise ValueError(
                "Command to obtain API key failed with"
                f" stdout='{stdout}', stderr='{stderr}'"
            )
        return stdout.decode().split("\n")[0]


config = get_config()
api_key = get_api_key()
ledger_date_format = config.get("ledger_date_format", "%Y/%m/%d")


def fetch(endpoint):
    url = urljoin("https://api.monobank.ua", endpoint)
    request = Request(url, headers={"X-Token": api_key})
    response = urlopen(request)
    return json.load(response.fp)


def get_attribute(self, path):
    result = self.json
    for key in path.split("."):
        result = result.get(key)
    return result


# TODO: Can maybe be defined as variables instead of functions to make this tidier
def json_property(path):
    return property(lambda self: get_attribute(self, path))


def json_amount_property(path):
    return property(lambda self: get_attribute(self, path) / 100)


def json_currency_property(path, kind="numeric"):
    return property(
        lambda self: currencies.get(**{kind: str(get_attribute(self, path))})
    )


def json_timestamp_property(path):
    return property(lambda self: datetime.fromtimestamp(get_attribute(self, path)))


class JSONObject:
    json: dict = {}

    def __init__(self, _object: str | dict = None, **kwargs):
        if _object:
            if isinstance(_object, str):
                self.json = json.loads(_object)
            else:
                self.json = _object

        self.json |= kwargs

    def __repr__(self):
        return str(self.json)


class StatementItem(JSONObject):
    account = None
    id = json_property("id")
    time = json_timestamp_property("time")
    description = json_property("description")
    # TODO: Figure out difference between mcc and originalMcc
    mcc = json_property("mcc")
    original_mcc = json_property("originalMcc")
    currency = json_currency_property("currencyCode")
    # Amount is the amount in card value and operationAmount is
    # value in foreign currency if exchange is done.
    # operationAmount == amount if currencyCode == card currencyCode
    amount = json_amount_property("amount")
    operation_amount = json_amount_property("operationAmount")
    cashback = json_amount_property("cashbackAmount")
    # Commission is only available i.e. when transfering between
    # different banks. For now store and ignore it but for future
    # TODO: handle commission
    commission = json_amount_property("comissionRate")
    # Account balance after operation
    balance = json_amount_property("balance")
    # See https://en.wikipedia.org/wiki/Authorization_hold
    hold = json_property("hold")
    # Currently unused, but in future might want to add it as a tag
    receipt_id = json_property("receiptId")
    # NOTE: When amount is positive this is data of sender and when it is negative this
    # is data of receiver
    recepient_name = json_property("counterName")
    recepient_iban = json_property("counterIban")
    recepient_edrpou = json_property("counterEdrpou")

    def __init__(self, _object=None, account=None, **kwargs):
        super().__init__(_object, **kwargs)
        self.account = account

    @property
    def is_send(self):
        return self.operation_amount < 0

    @property
    def is_receive(self):
        return self.operation_amount > 0


class Account(JSONObject):
    id = json_property("id")
    type = json_property("type")
    iban = json_property("iban")
    balance = json_amount_property("balance")
    credit_limit = json_amount_property("creditLimit")
    currency = json_currency_property("currencyCode")
    cashback_type = json_currency_property("cashbackType", "alpha_3")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._statements = []

    def fetch_statements(self, from_time: datetime, to_time: datetime):
        if self._statements:
            raise ValueError(
                "Statements were already fetched."
                " Fetching multiple times with different dates is not supported"
            )
        intervals = []
        if (to_time - from_time).days <= 30:
            intervals.append([from_time, to_time])
        else:
            current_interval = to_time - from_time
            current_time = from_time
            # TODO: These is probably a nicer way to do this with recursion
            while current_interval.days > 30:
                # This can do requests with current timestampt in the future but API
                # does not seem to care and neither do I
                interval = current_time + timedelta(days=30)
                intervals.append([current_time, interval])
                current_interval -= 30
                current_time = interval

        for from_time, to_time in intervals:
            try:
                response = fetch(
                    "/personal/statement"
                    f"/{self.id}"
                    f"/{int(from_time.timestamp())}"
                    f"/{int(to_time.timestamp())}"
                )
                # TODO: Better error handler - in particular throttling should be
                # handled well
            except HTTPError as e:
                print(e.read().decode())
                raise e
            # TODO: Handle case where there are no statements returned
            for statement in response:
                self._statements.append(StatementItem(statement, account=self))

    @property
    def statements(self):
        if not self._statements:
            raise ValueError("You need to fetch statements first")
        return self._statements

    def filter_statements(
        self, from_time: datetime = None, to_time: datetime = None, **kwargs
    ):
        if not self._statements:
            raise ValueError("You need to fetch statements first")

        def matcher(x):
            predicates: list[bool] = [
                all(getattr(x, key) == value for key, value in kwargs.items())
            ]
            if from_time:
                predicates.append(x.time >= from_time)
            if to_time:
                predicates.append(x.time <= to_time)

            return all(predicates)

        return filter(matcher, self._statements)


def get_last_transaction_date(file):
    """
    Return date of the last ledger transaction in file.
    """
    pattern = re.compile(r"\d{4}[/|-]\d{2}[/|-]\d{2}")
    # No way to match multiline comments but eh, unless someone requests it it is
    # hledger-only feature anyway
    comment_pattern = re.compile(r"^\s*[;#*]+")
    result = None
    inside_comment = False
    for line in file.readlines():
        # Exclude hledger multi-line comments
        if not inside_comment and line == "comment\n":
            inside_comment = True
        elif inside_comment and line == "end comment\n":
            inside_comment = False
        if (
            not inside_comment
            and not comment_pattern.match(line)
            and (match := pattern.findall(line))
        ):
            result = match[0]
    if not result:
        # TODO: Descriptive error
        raise ValueError

    return datetime.strptime(result, ledger_date_format)


def fetch_accounts() -> list[Account]:
    response = fetch("/personal/client-info")

    return [
        Account(account)
        for account in response["accounts"]
        if account["id"] not in config["ignored_accounts"]
    ]


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input", type=argparse.FileType("r"))
    parser.add_argument("output", type=argparse.FileType("w"), nargs="?")
    args = parser.parse_args(sys.argv[-1:])
    last_transaction_date = get_last_transaction_date(args.input)
    now = datetime.now()
    header_datetime = now.strftime(HEADER_DATETIME_FORMAT)
    header = f"\n;; Begin mono2ledger output\n;; Date and time: {header_datetime}\n"
    footer = ";; End mono2ledger output\n"

    accounts = fetch_accounts()
    for account in accounts:
        # TODO: Add indication that we are waiting. Just printing is kinda ugly
        # ngl, I want something better than this for loop
        account.fetch_statements(from_time=last_transaction_date, to_time=now)
        print(f"Fetched statement for {account.id}. Waiting 60 seconds for throttle")
        # TODO: Is there a cleaner way to do the same thing without accessing list?
        if account != accounts[-1]:
            time.sleep(60)

    def get_matching_account(**kwargs):
        return next(
            filter(
                lambda x: all(
                    getattr(x, key) == value for key, value in kwargs.items()
                ),
                accounts,
            ),
            None,
        )

    def guess_account(statement):
        description = statement.description
        # TODO: Just use conunterIban instead of coming up with new names
        if statement.recepient_iban:
            return get_matching_account(iban=statement.recepient_iban)
        if "ФОП" in description:
            card_type = "fop"
        elif matches := re.match(r".*(чорн|біл)(у|ої).*", description):
            matched_card = matches[1]
            if matched_card.startswith("чорн"):
                card_type = "black"
            elif matched_card.startswith("біл"):
                card_type = "white"

        if matches := re.match(r".*(гривне|євро|долар)(вий|вого).*", description):
            matched_currency = matches[1]
            currency = None
            if matched_currency.startswith("гривн"):
                currency = currencies.get(alpha_3="UAH")
            elif matched_currency.startswith("євро"):
                currency = currencies.get(alpha_3="EUR")
            elif matched_currency.startswith("долар"):
                currency = currencies.get(alpha_3="USD")
            if currency:
                return get_matching_account(currency=currency, type=card_type)

    def format_ledger_transaction(statement, source_statement=None):
        # TODO: get_account whihc will return account funds came from based on
        # account, maybe from config
        # TODO: get_to_account which will return appropriate account for expense
        # transaction. Make sure to take into account that there are not only expenses

        def int_if_no_decimal(num: float) -> int | float:
            """
            Convert num to integer if it's decimal point == 0 else return it unmodified
            """
            return int(num) if num % 1 == 0.0 else num

        exchange_amount = None
        exchange_currency = None
        if source_statement:
            payee = config["transfer_payee"]
            to_account = config["account"][statement.account.id]["name"]
            from_account = config["account"][source_statement.account.id]["name"]
            amount = statement.amount
            if source_statement.amount != source_statement.operation_amount:
                exchange_amount = source_statement.amount
                exchange_currency = source_statement.account.currency
        else:
            payee = f"{statement.description}"
            from_account = config["account"][statement.account.id]["name"]
            to_account = f"statement_id:{statement.id}"
            amount = -statement.amount
            if statement.amount != statement.operation_amount:
                exchange_amount = statement.amount
                exchange_currency = statement.currency

        if statement.is_receive:
            to_account, from_account = from_account, to_account
            amount = -amount
            exchange_amount = -exchange_amount

        exchange = (
            f" @@ {-exchange_amount} {exchange_currency.alpha_3}"
            if exchange_amount and exchange_currency
            else ""
        )

        # TODO: Trim zero does not have signed digits
        # TODO: When the transaction is income swap recepiend and from account
        return (
            f"{statement.time.strftime(ledger_date_format)} {payee}\n"
            f"\t{to_account:60} {amount:8} {statement.account.currency.alpha_3}"
            f"{exchange}\n"
            f"\t{from_account}\n"
        )

    def find_source(statement):
        if statement.mcc == TRANSFER_MCC:
            if statement.is_send:
                filters = {"from_time": statement.time - timedelta(minutes=5)}
            else:
                filters = {"to_time": statement.time + timedelta(minutes=5)}

            filters |= {
                "mcc": TRANSFER_MCC,
                "currency": statement.currency,
                "operation_amount": -statement.operation_amount,
            }

            if account := (
                statement.account if statement.is_send else guess_account(statement)
            ):
                matched_statement = next(
                    account.filter_statements(**filters), statement
                )
                if matched_statement != statement:
                    return find_source(matched_statement)
        return statement

    def get_source(statement):
        if statement.mcc == TRANSFER_MCC and (account := guess_account(statement)):
            return find_source(statement, account)
        return statement

    statements = sorted(
        (statement for account in accounts for statement in account.statements),
        key=lambda x: (x.time, x.amount),
    )
    cross_card_statements = []
    normal_statements = []

    for statement in statements:
        account = guess_account(statement)
        source = find_source(statement)
        if source != statement:
            # Due to the way statements are sorted we know that the next matching
            # statement is the destination, and the source is always the same
            if result := next(
                filter(
                    lambda x: source in x[1] or statement in x[1],
                    enumerate(cross_card_statements),
                ),
                None,
            ):
                index = result[0]
                cross_card_statements[index].append(statement)
            else:
                cross_card_statements.append([statement, source])
        elif not account:
            normal_statements.append(statement)

    all_statements = sorted(
        itertools.chain(cross_card_statements, normal_statements),
        key=(
            lambda x: (x.time, x.amount)
            if not isinstance(x, list)
            else (x[0].time, x[0].amount)
        ),
    )
    for statement in all_statements:
        if isinstance(statement, list):
            sorted_cross_card_statement = sorted(
                statement, key=lambda x: (x.time, x.amount), reverse=True
            )
            print(
                format_ledger_transaction(
                    sorted_cross_card_statement[0], sorted_cross_card_statement[-1]
                )
            )
            pass
        else:
            print(format_ledger_transaction(statement))

    # print(footer)
