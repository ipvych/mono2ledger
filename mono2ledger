#!/usr/bin/env python3
import argparse
import configparser
import csv
import json
import os
import re
import shlex
import subprocess
import textwrap
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from urllib.request import Request, urlopen

from pycountry import currencies

Currency = list(currencies)[0].__class__
# Datetime formed used in statement
STATEMENT_DATETIME_FORMAT = "%d.%m.%Y %H:%M:%S"
# Date format used by ledger

# Datetime format used in header
HEADER_DATETIME_FORMAT = "%Y/%m/%d %H:%M:%S"

INCOME_KEY = "income"
OUTCOME_KEY = "outcome"
PAYEE_KEY = "payee"


# Get config file from xdg config dir
def get_config():
    """Return parsed content of config file."""
    config_file = os.path.join(
        os.getenv("XDG_CONFIG_HOME", os.path.expanduser("~/.config")),
        "mono2ledger/config.ini",
    )
    with open(config_file, "rb") as file:
        config = configparser.ConfigParser(interpolation=None)
        config.read(config_file)
        return config


def get_api_key():
    config_command = config["DEFAULT"].get("api_key_command")
    if command := (config_command or os.getenv("MONO2LEDGER_API_KEY_COMMAND")):
        proc = subprocess.Popen(
            shlex.split(command), stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = proc.communicate()
        if proc.returncode != 0:
            raise ValueError(
                "Command to obtain API key failed with"
                f" stdout='{stdout}', stderr='{stderr}'"
            )
        return stdout.decode().split("\n")[0]


config = get_config()
cashback_account = config["DEFAULT"]["cashback_account"]
cashback_payee = config["DEFAULT"]["cashback_payee"]
card_account = config["DEFAULT"]["card_account"]
ledger_date_format = config["DEFAULT"].get("ledger_date_format", "%Y/%m/%d")


def get_statement_item_config(item):
    """
    Return config data for provided statement item.
    Raise exception when there is none
    """

    for key in config:
        # Default key only holds settings, not interested in it
        if key == "DEFAULT":
            continue

        mcc = key.split("/")[0]
        regexp = "".join(key.split("/")[1:])

        if str(item.mcc) == mcc and re.match(regexp, item.description):
            return config[key]

    raise ValueError(
        f"There is no matching config for entry {item.mcc} {item.description}"
    )


@dataclass
class StatementItem:
    datetime: datetime
    description: str
    mcc: str
    currency_amount: float
    operation_amount: float
    currency: Currency
    exchange_rate: Optional[float]
    commission: Optional[float]
    cashback: Optional[float]

    def account_name(self):
        """
        Return account name associated with this item.
        """
        config = get_statement_item_config(self)
        return config[INCOME_KEY] if self.currency_amount > 0 else config[OUTCOME_KEY]

    def payee(self):
        """
        Return payee associated with this item.
        """
        payee = get_statement_item_config(self).get(PAYEE_KEY)
        if payee is None:
            payee = "UNKNOWN"
            print(f"Unknown payee for entry {self.mcc} {self.description}")
        return payee

    def to_ledger(self):
        """
        Return ledger representation of this entry.
        """
        account = self.account_name()
        payee = self.payee()
        date = self.datetime.strftime(ledger_date_format)

        ret = (
            f"{date} {payee}\n"
            f"    {account:60} {-self.currency_amount:8} {self.currency}\n"
            f"    {card_account}\n"
        )
        if self.cashback:
            ret += (
                f"\n{date} {cashback_payee}\n"
                f"    {cashback_account:60} {-self.cashback:8} {self.currency}\n"
                f"    {cashback_account}\n"
            )

        return ret

    def _check_fields(self):
        """
        Assert that not yet supported fields dont have unexpected values
        """
        assert self.currency_amount == self.operation_amount
        assert self.exchange_rate is None
        assert self.currency == "UAH"

    def __post_init__(self, **kwargs):
        self._check_fields()


class CSVStatementItem(StatementItem):
    def __init__(self, row):
        def get_col(pos):
            """Return value from column, None if column is empty."""
            col = row[pos]
            return col if col != "â€”" else None

        def float_or_none(val):
            """
            Return value converted to float if it is not None or None
            """
            return float(val) if val else None

        super().__init__(
            datetime=datetime.strptime(row[0], STATEMENT_DATETIME_FORMAT),
            description=get_col(1),
            mcc=get_col(2),
            currency_amount=float(get_col(3)),
            operation_amount=float(get_col(4)),
            currency=get_col(5),
            exchange_rate=float_or_none(get_col(6)),
            commission=float_or_none(get_col(7)),
            cashback=float_or_none(get_col(8)),
        )


class JSONStatementItem(StatementItem):
    def __init__(self, item):
        def amount_to_float(val):
            """
            monobank stores floats as ints with last two numbers being
            cents, convert it to float
            """
            return val / 100

        rate = item["operationAmount"] / item["amount"]
        super().__init__(
            datetime=datetime.fromtimestamp(item["time"]),
            description=item["description"],
            mcc=item["mcc"],
            currency_amount=amount_to_float(item["amount"]),
            operation_amount=amount_to_float(item["operationAmount"]),
            currency=currencies.get(numeric=str(item["currencyCode"])).alpha_3,
            exchange_rate=rate if rate != 1.0 else None,
            commission=amount_to_float(item["commissionRate"]),
            cashback=amount_to_float(item["cashbackAmount"]),
        )


def get_last_transaction_date(ledger_file):
    """
    Return date of the last ledger transaction.
    """
    TRANSACTION_PATTERN = re.compile(r"\d{4}[/|-]\d{2}[/|-]\d{2}")

    for line in ledger_file.readlines():
        if match := TRANSACTION_PATTERN.findall(line):
            result = match[0]
    return datetime.strptime(result, ledger_date_format)


def fetch_statement(api_key, from_time, to_time):
    """
    Fetch statement in json format.
    Account 0 just uses default account, I have no idea how to get
    account ids.
    """

    # 0 for default account
    # TODO: Fetch statements with intervals to resolve 30 days limit
    # TODO: Work around issue with api only returning 500 results
    request = Request(
        (
            "https://api.monobank.ua/personal/statement"
            f"/0/{from_time.timestamp()}/{to_time.timestamp()}"
        ),
        headers={"X-Token": api_key},
    )
    response = urlopen(request)
    return json.load(response.fp)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert monobank csv statement to ledger transactions.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument(
        "-f",
        "--ledger-file",
        help=textwrap.dedent(
            """\
            Ledger file to parse to obtain the date of last transaction.
            If not provided then when importing from csv all transactions will be
            imported and when importing from API transactions for the last 30 days will
            be imported.
            Providing this option overrides same option from config
        """
        ),
        type=argparse.FileType(),
    )
    parser.add_argument(
        "statements",
        nargs="*",
        help="CSV statements from monobank",
        type=argparse.FileType(),
    )

    args = parser.parse_args()
    now = datetime.now()
    if ledger_file := args.ledger_file:
        last_transaction_date = get_last_transaction_date(ledger_file)
    elif path := config["DEFAULT"].get("ledger_file"):
        with open(os.path.expanduser(path)) as ledger_file:
            last_transaction_date = get_last_transaction_date(ledger_file)
    else:
        last_transaction_date = None

    header_datetime = now.strftime(HEADER_DATETIME_FORMAT)

    print(f"\n;; Begin converter output\n" f";; Date and time: {header_datetime}")

    if statements := args.statements:
        for file in statements:
            reader = csv.reader(file)
            next(reader)  # Skip field titles
            for row in reversed(list(reader)):
                item = CSVStatementItem(row)
                if last_transaction_date:
                    if item.datetime > last_transaction_date:
                        print(item.to_ledger())
                else:
                    print(item.to_ledger())
    else:
        api_key = get_api_key()
        if not last_transaction_date:
            last_transaction_date = now - timedelta(days=30)
        for statement in reversed(fetch_statement(api_key, last_transaction_date, now)):
            print(JSONStatementItem(statement).to_ledger())

    print(";; End converter output")
